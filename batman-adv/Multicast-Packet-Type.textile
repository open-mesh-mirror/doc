h1. DRAFT - Multicast Packet Type

_This is a draft and not implemented at the moment._

h2. Brief

Reduce number of packets / overhead by introducing a new batman-adv multicast packet type which is capable of holding multiple destination addresses.

h2. Current State

batman-adv now has IP multicast group awareness. And with that can detect in advance which other nodes want to receive an IPv4/IPv6 multicast packet for a specific multicast destination/multicast group.

The sender algorithm so far is simply either sending a packet via one batman-adv unicast packet for each interested destination node:

!{width: 66%;}https://www.open-mesh.org/attachments/download/888/basic-multicast-multiple-receivers.png!

Or when the number of destination is larger than 16 (default, configurable) it will fall back to using a single batman-adv broadcast packet:

!{width: 66%;}https://www.open-mesh.org/attachments/download/890/basic-multicast-many-receivers.png!

The former method is more efficient when the number of interested nodes is rather small. And allows bothering less nodes in the mesh and by that then generating less overhead in the overall mesh. However it still often leads to duplicated transmissions of the multicast IP packet especially on the first hops.

For more details see:
* [[Multicast-optimizations]]

h2. Technical Specification

MCAST packet type header:

<pre><code>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Packet Type  |  Version      |  TTL          | reserved      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  TVLV length                  |  MCAST Tracker TVLV ...       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
   |  ...                          |  Data ...                     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
   |  ...                                                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>

* Packet Type: BATADV_MCAST (0x05)
* Version: 15
* TTL:
* reserved: 0x00
* TVLV length:
* Data: Encapsulated ethernet frame with 2 byte alignment (to make IP packets 4 byte aligned)


MCAST Tracker TVLV:

<pre><code>    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  TVLV Type    |  TVLV Version |  TVLV Length                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  #Num Dests (N)               |  [padding]                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Dest 1 ...                                                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  ...                          |  Dest 2 ...                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  ...                                                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  ...                          |  Dest N ...                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  ...                                                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>

* TVLV Type: 0x07
* TVLV Version: 1
* #Num Dests: Number of destinations (originator MAC addresses)
* [padding]: Optional, only present if #Num Dests are even, to make Tracker TVLV 4 byte aligned (to make encapsulated IP packets 4 byte aligned)

h4. -Preparations for Multicast Tracker Packets (future enhancements)
-
-The fields _Tracker-ID_ and _MCAST Address_ will not be used in the initial implementation of the batman-adv multicast packet type. But they are in preparation for the future enhancements where control and data plane can be separated. That is where batman-adv multicast packets can also be send without _Data_ (_Multicast Tracker Packets_) and the destinations are cached on nodes on the path. And then further batman-adv multicast packets could be send with _Data_ but with a zero length TVLV, so without the destination addresses.-

h2. Implementation Tasks

*All nodes:*
* Signalize Multicast Packet capability to other nodes (add flag to BATADV_TVLV_MCAST)

*Forwarding Nodes:*
* Parse Multicast Packet Type, potentially split multicast packet if multiple next hops to forward to

*Receiving Nodes:*
* Decapsulate: Remove batman-adv multicast packet header, forward to upper interface (bat0)

*Originating Nodes:*
# Check if all (optimization: on path) batman-adv originators support Multicast Packet Capability
# If yes, further check if number of batman-adv multicast per IP multicast packet is smaller than multicast fanout setting. So calculate MTU - sizeof(_Data_) - sizeof(multicast-packet-header) and divide by number of destinations (check Translation Table). If it exceeds multicast fanout then bail out and fall back to broadcast flooding. Otherwise continue:
#

h2. Open questions, known issues, TODOs

h3. #Num Dests size

* 1 or 2 bytes for #Num Dests for Address X?
** If limit of entries were reached, we could just send another
    mcast packet? (~6*256 = 1536). Or do we want to be prepared
    for jumbo frames?

---

-> going for 2 bytes / potential jumbo frame support

h3. Non ideal splits

If a packet with n destinations gets too large for the MTU then batman-adv would/should/could try to split it into m packets with n/3 destinations each. where m <= mcast_fanout.

However when splitting like this then such the splitting node does not know the best sorting into these m packets. Another node will likely later need to split again due to different next hops for the destinations in a packet.

A batman-adv node currently cannot anticipate this for optimized splitting, as it does not know the full topology. Which would potentially lead to more transmissions than necessary.

---

-> Going for just one multicast packet instead of up to mcast_fanout to start with, for simplicity.

h3. Fragmentation / MTUs: 

On transit a forwarding node might have an interface with a smaller MTU than the node which originated the packet. A node could try to split a packet into multiple packets with less destinations. However if the payload data is larger than the interface MTU already then it would still not fit. And the batman-adv fragmentation code won't be able to look into and split within a multicast packet type header.

Workaround A):

By default only apply multicast packet type if resulting packet is smaller than 1280 (minimum IPv6 packet size) or even 576 (minimum accepeted IPv4 datagram size?). Maybe add a configuration option, which defaults to 576 bytes? While in practice configuring it to 1280 should usually be fine these days with IPv6 capable networks.

Solution B)

Later ideally the fragmentation code would be able to split the payload within a multicast packet type, while leaving multicast packet type headers in tact. A node should still forward packets if due to this splitting the mcast-fanout limit were violated, to avoid packet loss.

h3. Adding a sequence number? / How to avoid loops with tracker marking later?

When later implementing a split control <-> data plane as originally envisioned, by allowing to send a multicast packet with only the tracker TVLV, without data. And caching this information to fill a multicast routing table. And then allowing to send a multicast packet without the tracker TVLV afterwards, there is the following issue:

When first a path is marked through the tracker TVLV, then paths change due to OGM updates. And then a tracker packet marks such new paths then the merger of both the old and newly tracker marked paths could create routing loops, as the old path is not automatically invalidated.

Solution:

Don't mark paths. Instead use the tracker TVLV to fill a cache with the mcast/dests lists and assign a hash to this information. Then later send the multicast data with a TVLV containing only this hash instead of the full mcast/dests list. Therefore a specific list of destinations is still maintained and routing decisions still happen on the go, loopfree, instead of trying to a maintain a loopfree, adjacent multicast routing table.